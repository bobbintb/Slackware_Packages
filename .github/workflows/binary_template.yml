name: Binary workflow template
on:
  workflow_call:
    inputs:
      NAME:
        description: 'Program name'
        required: true
        type: string
      LATEST_VERSION:
        description: 'Use the latest program version (ignores VERSION)'
        required: false
        type: string
      VERSION:
        description: 'Program version'
        required: false
        type: string
      BUILD:
        description: 'Program build number'
        required: false
        type: string
      BINARY:
        description: 'URL of the binary to package.'
        required: true
        type: string
      LICENSE:
        description: 'URL of the LICENSE to package.'
        required: false
        type: string
      README:
        description: 'URL of the README to package.'
        required: false
        type: string
      extra_prep:
        description: 'Extra prep'
        required: false
        type: string
        default: false
jobs:
  slackbuild_and_upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    container:
      image: bobbintb/unraid-cicd-builder-upgraded
      options: --privileged
    steps:
    - 
      name: Checkout
      uses: actions/checkout@v4
      with:
        clean: true
    -
      name: Import GPG key
      uses: crazy-max/ghaction-import-gpg@v6
      with:
        gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
        passphrase: ${{ secrets.PASSPHRASE }}
    - name: Cache packages
      id: cache-packages
      uses: actions/cache@v4
      with:
        path: /var/cache/packages
        key: slackware-packages-${{ github.sha }}
        restore-keys: |
          slackware-packages-
        # key: ${{ runner.os }}-slackpkg-${{ hashFiles('**/package-list.txt') }}
        # restore-keys: |
        #   ${{ runner.os }}-slackpkg-
        #key: slackpkg-${{ runner.os }}-${{ inputs.VERSION }}-${{ hashFiles('SlackBuilds/**/*') }}
        #restore-keys: |
        #  slackpkg-${{ runner.os }}-${{ inputs.VERSION }}-
    - 
      name: Check existing build and increment build number if needed
      run: |
        REPO=${GITHUB_REPOSITORY##*/}
        REPO_DIR="/__w/${REPO}/${REPO}"
        EXISTING_BUILD_DIR="${REPO_DIR}/builds/${{ inputs.NAME }}"
        
        echo "Checking for existing builds in: $EXISTING_BUILD_DIR"
        
        if [ -d "$EXISTING_BUILD_DIR" ]; then
          # Look for existing package files with the same version
          EXISTING_PACKAGE=$(find "$EXISTING_BUILD_DIR" -name "${{ inputs.NAME }}-${VERSION}-*-*_SBo.t*z" 2>/dev/null | head -n 1)
          
          if [ -n "$EXISTING_PACKAGE" ]; then
            echo "Found existing package: $(basename "$EXISTING_PACKAGE")"
            
            # Extract the current build number from the filename
            # Pattern: name-version-arch-build_SBo.tgz
            CURRENT_BUILD=$(basename "$EXISTING_PACKAGE" | sed -n "s/.*-${VERSION}-[^-]*-\([0-9]*\)_SBo\.t.*z/\1/p")
            
            if [ -n "$CURRENT_BUILD" ]; then
              # Increment the build number
              NEW_BUILD=$((CURRENT_BUILD + 1))
              echo "Current build number: $CURRENT_BUILD"
              echo "Incrementing to build number: $NEW_BUILD"
              
              # Export the new build number (override any existing BUILD input)
              echo "BUILD=$NEW_BUILD" >> $GITHUB_ENV
              export BUILD=$NEW_BUILD
            else
              echo "Could not extract build number from existing package"
              # Use provided BUILD input or default to 1
              if [ -n "${{ inputs.BUILD }}" ] && [ "${{ inputs.BUILD }}" != "null" ]; then
                echo "BUILD=${{ inputs.BUILD }}" >> $GITHUB_ENV
                export BUILD=${{ inputs.BUILD }}
              else
                echo "BUILD=1" >> $GITHUB_ENV
                export BUILD=1
              fi
            fi
          else
            echo "No existing package found for version $VERSION"
            # Use provided BUILD input or default to 1
            if [ -n "${{ inputs.BUILD }}" ] && [ "${{ inputs.BUILD }}" != "null" ]; then
              echo "BUILD=${{ inputs.BUILD }}" >> $GITHUB_ENV
              export BUILD=${{ inputs.BUILD }}
            else
              echo "BUILD=1" >> $GITHUB_ENV
              export BUILD=1
            fi
          fi
        else
          echo "No existing builds directory found"
          # Use provided BUILD input or default to 1
          if [ -n "${{ inputs.BUILD }}" ] && [ "${{ inputs.BUILD }}" != "null" ]; then
            echo "BUILD=${{ inputs.BUILD }}" >> $GITHUB_ENV
            export BUILD=${{ inputs.BUILD }}
          else
            echo "BUILD=1" >> $GITHUB_ENV
            export BUILD=1
          fi
        fi
        
        echo "Final BUILD number: $BUILD"
    - 
      name: Build
      run: |
        REPO=${GITHUB_REPOSITORY##*/}
        REPO_DIR="/__w/${REPO}/${REPO}"
        DEST_DIR=${REPO_DIR}/builds/${{ inputs.NAME }}
        echo "DEST_DIR=${DEST_DIR}" >> $GITHUB_ENV
        mkdir -p $DEST_DIR
        if [ "${{ inputs.BUILD }}" != "" ] && [ "${{ inputs.BUILD }}" != "null" ]; then
          export BUILD=${{ inputs.BUILD }}
        fi
        export VERSION=$VERSION
        echo "version"
        echo $VERSION

        /tmp/SBo/package-test/usr/bin/test



        PRGNAM=${{ inputs.NAME }}
        VERSION=${VERSION:-1}
        BUILD=${BUILD:-1}
        TAG=${TAG:-_loom}


        # Automatically determine the architecture we're building on:
        if [ -z "$ARCH" ]; then
          case "$( uname -m )" in
            i?86) export ARCH=i586 ;;
            arm*) export ARCH=arm ;;
            # Unless $ARCH is already set, use uname -m for all other archs:
               *) export ARCH=$( uname -m ) ;;
          esac
        fi
        
        CWD=$(pwd)
        TMP=${TMP:-/tmp/SBo}	# For consistency's sake, use this
        PKG=$TMP/package-$PRGNAM
        OUTPUT=${OUTPUT:-/tmp}	# Drop the package in /tmp
        
        if [ "$ARCH" = "i586" ]; then
          SLKCFLAGS="-O2 -march=i586 -mtune=i686"
          LIBDIRSUFFIX=""
        elif [ "$ARCH" = "i686" ]; then
          SLKCFLAGS="-O2 -march=i686 -mtune=i686"
          LIBDIRSUFFIX=""
        elif [ "$ARCH" = "x86_64" ]; then
          SLKCFLAGS="-O2 -fPIC"
          LIBDIRSUFFIX="64"
        else
          SLKCFLAGS="-O2"
          LIBDIRSUFFIX=""
        fi
        
        set -e # Exit on most errors
        
        rm -rf $PKG
        mkdir -p $TMP $PKG $OUTPUT
        cd $TMP
        rm -rf $PRGNAM-$VERSION
        
        
        
        cd $PRGNAM-$VERSION
        chown -R root:root .
        find -L . \
         \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
          -o -perm 511 \) -exec chmod 755 {} \; -o \
         \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
          -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;

        mkdir -p $PKG/usr/bin
        wget -P $PKG/usr/bin ${{ inputs.BINARY }}

        
        # Compress man pages
        # If man pages are installed to /usr/share/man instead, you'll need to either
        # add the --mandir=/usr/man flag to configure or move them manually after the
        # make install process is run.
        find $PKG/usr/man -type f -exec gzip -9 {} \;
        for i in $( find $PKG/usr/man -type l ) ; do
          ln -s $( readlink $i ).gz $i.gz ; rm $i
        done
        
        # Compress info pages and remove the package's dir file
        # If no info pages are installed by the software, don't leave this in the script
        rm -f $PKG/usr/info/dir
        gzip -9 $PKG/usr/info/*.info*
        
        # Remove perllocal.pod and other special files that don't need to be installed,
        # as they will overwrite what's already on the system.  If this is not needed,
        # remove it from the script.
        # Remove 'special' files
        find $PKG -name "perllocal.pod" \
          -o -name ".packlist" \
          -o -name "*.bs" \
          | xargs rm -f
        
        # Copy program documentation into the package
        # The included documentation varies from one application to another, so be sure
        # to adjust your script as needed
        
        mkdir -p $PKG/usr/doc/$PRGNAM-$VERSION
        cp -a \
          <documentation> \
          $PKG/usr/doc/$PRGNAM-$VERSION
        
        mkdir -p $PKG/usr/doc/$PRGNAM-$VERSION
        cp -a \
           * \
           $PKG/usr/doc/$PRGNAM-$VERSION
        
        # Copy the slack-desc (and a custom doinst.sh if necessary) into ./install
        mkdir -p $PKG/install
        cat $CWD/slack-desc > $PKG/install/slack-desc
        [ -f $CWD/doinst.sh ] && cat $CWD/doinst.sh > $PKG/install/doinst.sh
        
        # Make the package; be sure to leave it in $OUTPUT
        # If package symlinks need to be created during install *before*
        # your custom contents of doinst.sh runs, then add the -p switch to
        # the makepkg command below -- see makepkg(8) for details
        cd $PKG
        /sbin/makepkg -l y -c n $OUTPUT/$PRGNAM-$VERSION-$ARCH-$BUILD$TAG.${PKGTYPE:-tgz}


        package_path=$OUTPUT/$PRGNAM-$VERSION-$ARCH-$BUILD$TAG.$PKGTYPE
                echo -e "\e[32mPackage path: ${package_path}\e[0m"
        echo "package_path=${package_path}" >> $GITHUB_ENV
        if [ -f "${package_path}" ]; then
          echo -e "\e[32mRemoving previous package from: $DEST_DIR\e[0m"
          rm -rf "$DEST_DIR"/*
          echo -e "\e[32mMoving package to: $DEST_DIR\e[0m"
        	mv ${package_path} $DEST_DIR
        fi
        git config --global --add safe.directory $REPO_DIR
    # - 
    #   name: Upload
    #   run: |
    #     echo -e "\e[32mContents of $DEST_DIR:\e[0m"
    #     ls -ls $DEST_DIR
    #     slackpkg update gpg || true
    #     slackpkg update || true
    #     slackpkg install slackware64:pinentry slackware64:libsecret slackware64:gtk+2 slackware64:tcl slackware64:expect
    #     FILES=$(find "$DEST_DIR" -type f -size +100M)
    #     if [ -n "$FILES" ]; then
    #       slackpkg install bobbintb:git-lfs
    #       git lfs install
    #       echo "$FILES" | while read -r FILE; do
    #         git lfs track "$FILE"
    #         echo -e "\e[32mTracked $FILE with Git LFS\e[0m"
    #       done
    #       git add .gitattributes
    #       cat .gitattributes
    #     fi
    #     cd ./builds/
    #     gpg --list-keys
    #     export REPOSOWNER="${{ github.repository_owner }}"
    #     export RSS_UUID=$(uuidgen -t)
    #     export REPOSROOT="/__w/Slackware_Packages/Slackware_Packages/builds"
    #     cat <<EOF > script.expect
    #     #!/usr/bin/expect
        
    #     set key [lindex $argv 0]
    #     spawn /usr/libexec/slackrepo/gen_repos_files.sh
    #     expect "Enter ChangeLog.txt description:"
    #     send "\r"
    #     expect "Enter your GPG passphrase:"
    #     send "\$key\r"
    #     expect eof
    #     EOF
    #     chmod +x /usr/libexec/slackrepo/gen_repos_files.sh
    #     chmod +x script.expect
    #     ./script.expect ${{ secrets.PASSPHRASE }}
    # - 
    #   name: Commit changes
    #   uses: stefanzweifel/git-auto-commit-action@v5
    #   with:
    #     commit_message: 'updated ${{ inputs.NAME }}'
    #     file_pattern: '*.txz *.tgz *.lst *.md5 *.meta *.txt *.gz *.bz2 *.TXT *.asc .gitattributes'
